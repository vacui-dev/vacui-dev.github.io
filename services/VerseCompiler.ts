// Copyright (c) 2025 vacui.dev, all rights reserved

import { NodeType, NodeGraph } from "../types/nodes";
import { WorldConfig, Entity } from "../types/simulation";
import { fileSystem } from "./FileSystem";

/**
 * VerseCompiler
 * Transpiles the internal World Model state (Entities + Logic Graphs) 
 * into valid Epic Games Verse code (.verse).
 */
class VerseCompilerService {

    public compile(config: WorldConfig, className: string = "generated_device"): string {
        const sb: string[] = [];

        // 1. Header / Imports
        sb.push("using { /Fortnite.com/Devices }");
        sb.push("using { /Verse.org/Simulation }");
        sb.push("using { /UnrealEngine.com/Temporary/Diagnostics }");
        sb.push("");
        sb.push(`# Auto-generated by Genesis World Model`);
        sb.push(`# Description: ${config.description}`);
        sb.push("");

        // 2. Class Definition
        sb.push(`${className} := class(creative_device):`);
        sb.push("");

        // 3. Properties (@editables)
        // Scan entities for logic or known types that map to devices
        const devices: string[] = [];
        
        config.entities.forEach(e => {
            const deviceType = this.mapEntityToDeviceType(e);
            if (deviceType) {
                const name = this.sanitizeName(e.name || e.id);
                sb.push(`    @editable`);
                sb.push(`    ${name} : ${deviceType} = ${deviceType}{}`);
                devices.push(name);
            }
        });

        sb.push("");

        // 4. OnBegin
        sb.push(`    OnBegin<override>()<suspends>:void=`);
        sb.push(`        Print("Genesis Simulation Started")`);
        
        // 5. Logic Wiring
        // Iterate entities with NodeGraphs and generate subscriptions
        config.entities.forEach(e => {
            if (e.logicParams && e.logicParams.nodeGraph) {
                const code = this.compileLogic(e, e.logicParams.nodeGraph);
                if (code) {
                    sb.push(code);
                }
            }
        });

        sb.push("");
        return sb.join("\n");
    }

    public export(config: WorldConfig) {
        const code = this.compile(config, "genesis_level_manager");
        const filename = `genesis_export_${Date.now()}.verse`;
        fileSystem.createFile('home', filename, 'text', code);
        return filename;
    }

    private mapEntityToDeviceType(e: Entity): string | null {
        if (e.type === 'InputTerminal') return 'switch_device'; // or button_device
        if (e.type === 'Ganglion') return 'sensor_device_placeholder'; 
        if (e.logicParams) return 'creative_prop'; // Generic prop with logic
        return null;
    }

    private sanitizeName(name: string): string {
        return name.replace(/[^a-zA-Z0-9_]/g, "");
    }

    private compileLogic(entity: Entity, graph: NodeGraph): string | null {
        const sb: string[] = [];
        const selfName = this.sanitizeName(entity.name || entity.id);

        // Find Inputs (Subscriptions)
        const inputNodes = graph.nodes.filter(n => n.type === NodeType.INPUT_RECEIVER);
        
        inputNodes.forEach(node => {
            const inputId = node.data.inputId;
            // Find what connects to this input in the logic graph
            // In Verse, we subscribe to events.
            // Example: Button.InteractedWithEvent.Subscribe(OnButtonPress)
            
            // For now, we generate a comment stub as the mapping is complex
            sb.push(`        # Logic for ${selfName}: Input ${inputId}`);
            
            // Find Impulse Nodes connected to this input
            // A simple DFS or edge trace would go here.
            // For the demo, we just assume direct connection logic
            sb.push(`        # TODO: Wire ${inputId} to Logic Graph execution`);
        });

        return sb.length > 0 ? sb.join("\n") : null;
    }
}

export const verseCompiler = new VerseCompilerService();